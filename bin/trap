#!/usr/bin/env bash
#
# trap - CLI tool for Trap task management
# Usage: trap <command> [args...]
#

set -euo pipefail

# Configuration
TRAP_URL="${TRAP_URL:-http://localhost:3002}"
VERSION="1.0.0"

# Colors for output (disabled if not terminal)
if [[ -t 1 ]]; then
  RED='\033[0;31m'
  GREEN='\033[0;32m'
  YELLOW='\033[1;33m'
  BLUE='\033[0;34m'
  CYAN='\033[0;36m'
  GRAY='\033[0;90m'
  BOLD='\033[1m'
  NC='\033[0m' # No Color
else
  RED='' GREEN='' YELLOW='' BLUE='' CYAN='' GRAY='' BOLD='' NC=''
fi

# Helper functions
error() {
  echo -e "${RED}Error:${NC} $1" >&2
  exit 1
}

warn() {
  echo -e "${YELLOW}Warning:${NC} $1" >&2
}

info() {
  echo -e "${BLUE}$1${NC}"
}

success() {
  echo -e "${GREEN}$1${NC}"
}

# API call helper
trap_api() {
  local method="$1"
  local endpoint="$2"
  local data="${3:-}"
  local query="${4:-}"
  
  local url="${TRAP_URL}${endpoint}"
  [[ -n "$query" ]] && url="${url}?${query}"
  
  local curl_opts=("-s" "-w" "\n%{http_code}")
  
  if [[ "$method" == "POST" || "$method" == "PATCH" ]]; then
    curl_opts+=("-X" "$method" "-H" "Content-Type: application/json")
    [[ -n "$data" ]] && curl_opts+=("-d" "$data")
  fi
  
  local response
  response=$(curl "${curl_opts[@]}" "$url")
  local http_code
  http_code=$(echo "$response" | tail -n1)
  local body
  body=$(echo "$response" | sed '$d')
  
  # Check for errors
  if [[ "$http_code" -ge 400 ]]; then
    local error_msg
    error_msg=$(echo "$body" | jq -r '.error // "Unknown error"' 2>/dev/null || echo "$body")
    error "HTTP $http_code: $error_msg"
  fi
  
  echo "$body"
}

# Get project ID from slug
get_project_id() {
  local slug="$1"
  local response
  response=$(trap_api "GET" "/api/projects/$slug")
  echo "$response" | jq -r '.project.id'
}

# Shorten UUID for display
short_id() {
  echo "${1:0:8}"
}

# Format status with color
format_status() {
  local status="$1"
  case "$status" in
    backlog)     echo -e "${GRAY}backlog${NC}" ;;
    ready)       echo -e "${GREEN}ready${NC}" ;;
    in_progress) echo -e "${YELLOW}in_progress${NC}" ;;
    in_review)   echo -e "${BLUE}in_review${NC}" ;;
    done)        echo -e "${GREEN}${BOLD}done${NC}" ;;
    *)           echo "$status" ;;
  esac
}

# Format priority with color
format_priority() {
  local priority="$1"
  case "$priority" in
    low)    echo -e "${GRAY}low${NC}" ;;
    medium) echo -e "${BLUE}medium${NC}" ;;
    high)   echo -e "${YELLOW}high${NC}" ;;
    urgent) echo -e "${RED}${BOLD}urgent${NC}" ;;
    *)      echo "$priority" ;;
  esac
}

# Commands
cmd_tasks_list() {
  local project_slug=""
  local status=""
  local limit=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project) project_slug="$2"; shift 2 ;;
      --status) status="$2"; shift 2 ;;
      --limit) limit="$2"; shift 2 ;;
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  if [[ -z "$project_slug" ]]; then
    # Try to get project from current git repo
    if git rev-parse --git-dir > /dev/null 2>&1; then
      local repo_url
      repo_url=$(git remote get-url origin 2>/dev/null || echo "")
      if [[ -n "$repo_url" ]]; then
        # List projects and find matching one
        local projects_response
        projects_response=$(trap_api "GET" "/api/projects")
        project_slug=$(echo "$projects_response" | jq -r ".projects[] | select(.github_repo != null) | select(\"$repo_url\" | contains(.github_repo)) | .slug" | head -1)
      fi
    fi
  fi
  
  if [[ -z "$project_slug" ]]; then
    error "Project slug required. Use --project <slug> or run from a git repo with a matching project."
  fi
  
  local project_id
  project_id=$(get_project_id "$project_slug")
  
  local query="projectId=${project_id}"
  [[ -n "$status" ]] && query="${query}&status=${status}"
  [[ -n "$limit" ]] && query="${query}&limit=${limit}"
  
  local response
  response=$(trap_api "GET" "/api/tasks" "" "$query")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  # Table output
  echo -e "${BOLD}ID        Title                                    Status        Priority  Role${NC}"
  echo -e "${GRAY}----      -----                                    ------        --------  ----${NC}"
  
  echo "$response" | jq -r '.tasks[] | "\(.id)\t\(.title)\t\(.status)\t\(.priority)\t\(.role // "-")"' | while IFS=$'\t' read -r id title status priority role; do
    printf "%-9s %-40s %-14s %-8s %s\n" \
      "$(short_id "$id")" \
      "${title:0:40}" \
      "$(format_status "$status")" \
      "$(format_priority "$priority")" \
      "${role:-}"
  done
  
  local count
  count=$(echo "$response" | jq '.tasks | length')
  echo
  echo -e "${GRAY}Total: $count tasks${NC}"
}

cmd_tasks_create() {
  local project_slug=""
  local title=""
  local description=""
  local priority="medium"
  local role=""
  local tags=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project) project_slug="$2"; shift 2 ;;
      --title) title="$2"; shift 2 ;;
      --description) description="$2"; shift 2 ;;
      --priority) priority="$2"; shift 2 ;;
      --role) role="$2"; shift 2 ;;
      --tags) tags="$2"; shift 2 ;;
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  [[ -z "$project_slug" ]] && error "--project is required"
  [[ -z "$title" ]] && error "--title is required"
  [[ -z "$role" ]] && error "--role is required"
  
  local project_id
  project_id=$(get_project_id "$project_slug")
  
  # Build JSON payload
  local payload
  payload=$(jq -n \
    --arg project_id "$project_id" \
    --arg title "$title" \
    --arg description "$description" \
    --arg priority "$priority" \
    --arg role "$role" \
    --arg tags "$tags" \
    '{
      project_id: $project_id,
      title: $title,
      description: ($description | select(length > 0)),
      priority: $priority,
      role: ($role | select(length > 0)),
      tags: ($tags | select(length > 0))
    } | with_entries(select(.value != null))'
  )
  
  local response
  response=$(trap_api "POST" "/api/tasks" "$payload")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  local task_id task_title
  task_id=$(echo "$response" | jq -r '.task.id')
  task_title=$(echo "$response" | jq -r '.task.title')
  
  success "Created task $(short_id "$task_id"): $task_title"
  echo "Full ID: $task_id"
}

cmd_tasks_get() {
  local task_id=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=true; shift ;;
      -*)
        if [[ -z "$task_id" ]]; then
          task_id="${1#--}"
        fi
        shift
        ;;
      *)
        if [[ -z "$task_id" ]]; then
          task_id="$1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -z "$task_id" ]] && error "Task ID is required"
  
  local response
  response=$(trap_api "GET" "/api/tasks/$task_id")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  # Pretty print task
  local task comments
  task=$(echo "$response" | jq '.task')
  comments=$(echo "$response" | jq '.comments // []')
  
  local id title status priority role description project_id
  id=$(echo "$task" | jq -r '.id')
  title=$(echo "$task" | jq -r '.title')
  status=$(echo "$task" | jq -r '.status')
  priority=$(echo "$task" | jq -r '.priority')
  role=$(echo "$task" | jq -r '.role // "-"')
  description=$(echo "$task" | jq -r '.description // ""')
  project_id=$(echo "$task" | jq -r '.project_id')
  
  echo -e "${BOLD}${title}${NC}"
  echo -e "${GRAY}ID: $(short_id "$id")${NC}"
  echo
  echo -e "Status:    $(format_status "$status")"
  echo -e "Priority:  $(format_priority "$priority")"
  echo -e "Role:      $role"
  echo -e "Project:   $project_id"
  
  if [[ -n "$description" && "$description" != "null" ]]; then
    echo
    echo -e "${BOLD}Description:${NC}"
    echo "$description" | fold -s -w 80
  fi
  
  # Comments
  local comment_count
  comment_count=$(echo "$comments" | jq 'length')
  if [[ "$comment_count" -gt 0 ]]; then
    echo
    echo -e "${BOLD}Comments ($comment_count):${NC}"
    echo
    
    echo "$comments" | jq -r '.[] | "\(.created_at)\t\(.author)\t\(.content)"' | while IFS=$'\t' read -r created_at author content; do
      local date_str
      date_str=$(date -d "@$((created_at / 1000))" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "$created_at")
      echo -e "${CYAN}${author}${NC} ${GRAY}($date_str)${NC}"
      echo "$content" | sed 's/^/  /'
      echo
    done
  fi
}

cmd_tasks_update() {
  local task_id=""
  local status=""
  local priority=""
  local title=""
  local tags=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --status) status="$2"; shift 2 ;;
      --priority) priority="$2"; shift 2 ;;
      --title) title="$2"; shift 2 ;;
      --tags) tags="$2"; shift 2 ;;
      --raw) raw=true; shift ;;
      -*)
        if [[ -z "$task_id" ]]; then
          task_id="${1#--}"
        fi
        shift
        ;;
      *)
        if [[ -z "$task_id" ]]; then
          task_id="$1"
        else
          # Second positional arg could be status for 'move' compatibility
          [[ -z "$status" ]] && status="$1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -z "$task_id" ]] && error "Task ID is required"
  [[ -z "$status" && -z "$priority" && -z "$title" && -z "$tags" ]] && error "Nothing to update (use --status, --priority, --title, or --tags)"
  
  # Build update payload
  local payload="{}"
  [[ -n "$status" ]] && payload=$(echo "$payload" | jq --arg s "$status" '. + {status: $s}')
  [[ -n "$priority" ]] && payload=$(echo "$payload" | jq --arg p "$priority" '. + {priority: $p}')
  [[ -n "$title" ]] && payload=$(echo "$payload" | jq --arg t "$title" '. + {title: $t}')
  [[ -n "$tags" ]] && payload=$(echo "$payload" | jq --arg t "$tags" '. + {tags: $t}')
  
  local response
  response=$(trap_api "PATCH" "/api/tasks/$task_id" "$payload")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  local new_title new_status
  new_title=$(echo "$response" | jq -r '.task.title // .task // empty')
  new_status=$(echo "$response" | jq -r '.task.status // .status // empty')
  
  success "Updated task $(short_id "$task_id")"
  [[ -n "$new_title" ]] && echo "Title: $new_title"
  [[ -n "$new_status" ]] && echo "Status: $(format_status "$new_status")"
}

cmd_tasks_move() {
  local task_id=""
  local new_status=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=true; shift ;;
      *)
        if [[ -z "$task_id" ]]; then
          task_id="$1"
        elif [[ -z "$new_status" ]]; then
          new_status="$1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -z "$task_id" ]] && error "Task ID is required"
  [[ -z "$new_status" ]] && error "New status is required"
  
  # Validate status
  case "$new_status" in
    backlog|ready|in_progress|in_review|done) ;;
    *) error "Invalid status: $new_status. Must be one of: backlog, ready, in_progress, in_review, done" ;;
  esac
  
  local payload
  payload=$(jq -n --arg status "$new_status" '{status: $status}')
  
  local response
  response=$(trap_api "PATCH" "/api/tasks/$task_id" "$payload")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  success "Moved task $(short_id "$task_id") to $(format_status "$new_status")"
}

cmd_tasks_comment() {
  local task_id=""
  local content=""
  local type="message"
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --type) type="$2"; shift 2 ;;
      --raw) raw=true; shift ;;
      *)
        if [[ -z "$task_id" ]]; then
          task_id="$1"
        elif [[ -z "$content" ]]; then
          content="$1"
        else
          content="$content $1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -z "$task_id" ]] && error "Task ID is required"
  [[ -z "$content" ]] && error "Comment content is required"
  
  # Validate type
  case "$type" in
    message|completion|request_input|note) ;;
    *) error "Invalid type: $type. Must be one of: message, completion, request_input, note" ;;
  esac
  
  local payload
  payload=$(jq -n --arg content "$content" --arg type "$type" '{
    content: $content,
    type: $type
  }')
  
  local response
  response=$(trap_api "POST" "/api/tasks/$task_id/comments" "$payload")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  success "Added comment to task $(short_id "$task_id")"
}

cmd_projects_list() {
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  local response
  response=$(trap_api "GET" "/api/projects")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  # Table output
  echo -e "${BOLD}Slug                 Name                           Work Loop  Max Agents${NC}"
  echo -e "${GRAY}----                 ----                           ---------  ----------${NC}"
  
  echo "$response" | jq -r '.projects[] | "\(.slug)\t\(.name)\t\(.work_loop_enabled)\t\(.work_loop_max_agents // "-")"' | while IFS=$'\t' read -r slug name enabled max; do
    local status_symbol="❌"
    [[ "$enabled" == "true" ]] && status_symbol="✅"
    printf "%-20s %-30s %-10s %s\n" "$slug" "${name:0:30}" "$status_symbol" "$max"
  done
  
  local count
  count=$(echo "$response" | jq '.projects | length')
  echo
  echo -e "${GRAY}Total: $count projects${NC}"
}

cmd_projects_get() {
  local slug_or_id=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=true; shift ;;
      *)
        if [[ -z "$slug_or_id" ]]; then
          slug_or_id="$1"
        fi
        shift
        ;;
    esac
  done
  
  [[ -z "$slug_or_id" ]] && error "Project slug or ID is required"
  
  local response
  response=$(trap_api "GET" "/api/projects/$slug_or_id")
  
  if [[ "$raw" == true ]]; then
    echo "$response" | jq .
    return
  fi
  
  local project task_count
  project=$(echo "$response" | jq '.project')
  task_count=$(echo "$project" | jq -r '.task_count // "?"')
  
  local id slug name description github_repo local_path work_loop_enabled work_loop_max_agents
  id=$(echo "$project" | jq -r '.id')
  slug=$(echo "$project" | jq -r '.slug')
  name=$(echo "$project" | jq -r '.name')
  description=$(echo "$project" | jq -r '.description // ""')
  github_repo=$(echo "$project" | jq -r '.github_repo // ""')
  local_path=$(echo "$project" | jq -r '.local_path // ""')
  work_loop_enabled=$(echo "$project" | jq -r '.work_loop_enabled')
  work_loop_max_agents=$(echo "$project" | jq -r '.work_loop_max_agents // "-"')
  
  echo -e "${BOLD}${name}${NC}"
  echo -e "${GRAY}ID: $(short_id "$id")${NC}"
  echo
  echo -e "Slug:           $slug"
  echo -e "GitHub:         ${github_repo:-${GRAY}none${NC}}"
  echo -e "Local Path:     ${local_path:-${GRAY}none${NC}}"
  echo -e "Work Loop:      $([[ "$work_loop_enabled" == "true" ]] && echo -e "${GREEN}enabled${NC}" || echo -e "${RED}disabled${NC}")"
  [[ "$work_loop_max_agents" != "-" ]] && echo -e "Max Agents:     $work_loop_max_agents"
  echo -e "Tasks:          $task_count"
  
  if [[ -n "$description" && "$description" != "null" ]]; then
    echo
    echo -e "${BOLD}Description:${NC}"
    echo "$description" | fold -s -w 80
  fi
}

cmd_cleanup_stuck() {
  local project_slug=""
  local fix=false
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --project) project_slug="$2"; shift 2 ;;
      --fix) fix=true; shift ;;
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  if [[ -z "$project_slug" ]]; then
    error "--project is required"
  fi
  
  local project_id
  project_id=$(get_project_id "$project_slug")
  
  if [[ "$fix" == true ]]; then
    # Get stuck tickets first
    local response
    response=$(trap_api "GET" "/api/cleanup/stuck-tickets" "projectId=${project_id}")
    
    if [[ "$raw" == true ]]; then
      echo "$response" | jq .
      return
    fi
    
    local stuck_ids
    stuck_ids=$(echo "$response" | jq -r '.stuck_tickets[].id')
    
    if [[ -z "$stuck_ids" ]]; then
      info "No stuck tickets found"
      return
    fi
    
    echo "Found stuck tickets. Auto-fixing..."
    for ticket_id in $stuck_ids; do
      echo -n "  $(short_id "$ticket_id")... "
      local fix_response
      fix_response=$(trap_api "POST" "/api/cleanup/stuck-tickets" \
        "{\"ticketId\":\"$ticket_id\",\"action\":\"ready\"}" 2>&1) && success "moved to ready" || warn "failed"
    done
  else
    local response
    response=$(trap_api "GET" "/api/cleanup/stuck-tickets" "projectId=${project_id}")
    
    if [[ "$raw" == true ]]; then
      echo "$response" | jq .
      return
    fi
    
    local count
    count=$(echo "$response" | jq '.stuck_tickets | length')
    
    if [[ "$count" -eq 0 ]]; then
      info "No stuck tickets found"
      return
    fi
    
    echo -e "${YELLOW}Found $count stuck ticket(s):${NC}"
    echo
    echo -e "${BOLD}ID        Title                                    Status${NC}"
    echo -e "${GRAY}----      -----                                    ------${NC}"
    
    echo "$response" | jq -r '.stuck_tickets[] | "\(.id)\t\(.title)\t\(.status)"' | while IFS=$'\t' read -r id title status; do
      printf "%-9s %-40s %s\n" "$(short_id "$id")" "${title:0:40}" "$(format_status "$status")"
    done
    
    echo
    echo "Use --fix to move these tickets back to 'ready'"
  fi
}

cmd_loop_status() {
  # The work-loop state is per-project, so we list all projects with their states
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  # Get all projects and check their work loop state
  local projects_response
  projects_response=$(trap_api "GET" "/api/projects")
  
  if [[ "$raw" == true ]]; then
    echo "$projects_response" | jq .
    return
  fi
  
  echo -e "${BOLD}Project              Status      Agents  Max  Last Cycle${NC}"
  echo -e "${GRAY}-------              ------      ------  ---  ----------${NC}"
  
  echo "$projects_response" | jq -r '.projects[] | select(.work_loop_enabled == true) | "\(.slug)\t\(.id)"' | while IFS=$'\t' read -r slug project_id; do
    # Check for loop state file or process
    local pid_file="/tmp/trap-loop.pid"
    local state="stopped"
    local agents="0"
    local max="3"
    local last_cycle="-"
    
    if [[ -f "$pid_file" ]]; then
      local pid
      pid=$(cat "$pid_file" 2>/dev/null)
      if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        state="running"
      fi
    fi
    
    # Get actual state from metrics if available
    local metrics
    metrics=$(curl -s "${TRAP_URL}/api/metrics" 2>/dev/null || echo "{}")
    agents=$(echo "$metrics" | jq -r '.active_agents // "0"')
    
    printf "%-20s %-11s %-7s %-4s %s\n" "$slug" "$state" "$agents" "$max" "$last_cycle"
  done
  
  echo
  echo -e "${GRAY}Check loop logs: tail -f /tmp/trap-loop.log${NC}"
}

cmd_loop_config() {
  local set_key=""
  local set_val=""
  local raw=false
  
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --set)
        set_key="${2%%=*}"
        set_val="${2#*=}"
        shift 2
        ;;
      --raw) raw=true; shift ;;
      *) shift ;;
    esac
  done
  
  if [[ -n "$set_key" ]]; then
    # Update config via the dynamic config API
    local payload
    payload=$(jq -n --arg key "$set_key" --arg val "$set_val" '{($key): $val}')
    
    local response
    response=$(curl -s -X PATCH "${TRAP_URL}/api/work-loop/config" \
      -H "Content-Type: application/json" \
      -d "$payload" \
      -w "\n%{http_code}")
    
    local http_code
    http_code=$(echo "$response" | tail -n1)
    
    if [[ "$http_code" -ge 400 ]]; then
      error "Failed to update config"
    fi
    
    success "Updated $set_key = $set_val"
  else
    # Get current config
    local response
    response=$(curl -s "${TRAP_URL}/api/work-loop/config")
    
    if [[ "$raw" == true ]]; then
      echo "$response" | jq .
      return
    fi
    
    echo -e "${BOLD}Work Loop Configuration:${NC}"
    echo
    echo "$response" | jq -r 'to_entries[] | "\(.key): \(.value)"' | while read -r line; do
      echo "  $line"
    done
  fi
}

# Help
cmd_help() {
  cat << 'EOF'
Usage: trap <command> [args...]

Commands:
  tasks list [--project <slug>] [--status <status>] [--limit N]
    List tasks for a project. Auto-detects project from git repo if not specified.

  tasks create --project <slug> --title "..." --description "..." --priority <p> --role <r> [--tags t1,t2]
    Create a new task.

  tasks get <id> [--raw]
    Get full details of a task including comments.

  tasks update <id> [--status s] [--priority p] [--title t] [--tags t1,t2]
    Update task fields.

  tasks move <id> <status>
    Move task to a new status (backlog, ready, in_progress, in_review, done).

  tasks comment <id> "message" [--type completion|request_input|note]
    Add a comment to a task.

  projects list
    List all projects.

  projects get <slug|id>
    Get details of a project.

  cleanup stuck [--project <slug>] [--fix]
    Find (and optionally fix) tickets stuck in in_review without open PRs.

  loop status
    Show work loop status across all projects.

  loop config [--set key=value]
    Get or set work loop configuration.

Global Options:
  --raw    Output raw JSON instead of formatted tables

Environment:
  TRAP_URL    Base URL for Trap API (default: http://localhost:3002)

Examples:
  trap tasks list --project the-trap
  trap tasks create --project the-trap --title "Fix bug" --role dev --priority high
  trap tasks get 6f788325
  trap tasks move 6f788325 in_review
  trap cleanup stuck --project the-trap --fix
EOF
}

# Main
cmd="${1:-}"
subcmd="${2:-}"

# Shift off command and subcommand
shift 2>/dev/null || true
shift 2>/dev/null || true

case "${cmd}:${subcmd}" in
  tasks:list)
    cmd_tasks_list "$@"
    ;;
  tasks:create)
    cmd_tasks_create "$@"
    ;;
  tasks:get)
    cmd_tasks_get "$@"
    ;;
  tasks:update)
    cmd_tasks_update "$@"
    ;;
  tasks:move)
    cmd_tasks_move "$@"
    ;;
  tasks:comment)
    cmd_tasks_comment "$@"
    ;;
  projects:list)
    cmd_projects_list "$@"
    ;;
  projects:get)
    cmd_projects_get "$@"
    ;;
  cleanup:stuck)
    cmd_cleanup_stuck "$@"
    ;;
  loop:status)
    cmd_loop_status "$@"
    ;;
  loop:config)
    cmd_loop_config "$@"
    ;;
  :|help:)
    cmd_help
    ;;
  *)
    error "Unknown command: $cmd $subcmd. Run 'trap help' for usage."
    ;;
esac
